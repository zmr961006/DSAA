#第九章 排序  折半插入排序

##折半插入排序

    折半插入排序（binary insertion sort）是对插入排序算法的一种改进，
    由于排序算法过程中，就是不断的依次将元素插入前面已排好序的序列中。由于前半部分为已排好序的
    数列，这样我们不用按顺序依次寻找插入点，可以采用折半查找的方法来加快寻找插入点的速度。
     
##具体操作

在将一个新元素插入已排好序的数组的过程中，寻找插入点时，将待插入区域的首元素设置为a[low]，末元素设置为a[high]，则轮比较时将待插入元素与a[m]，其中m=(low+high)/2相比较,如果比参考元素小，则选择a[low]到a[m-1]为新的插入区域(即high=m-1)，否则选择a[m+1]到a[high]为新的插入区域（即low=m+1），如此直至low<=high不成立，即将此位置之后所有元素后移一位，并将新元素插入a[high+1]。


##稳定性与复杂度

折半插入排序算法是一种稳定的排序算法，比直接插入算法明显减少了关键字之间比较的次数，因此速度比直接插入排序算法快，但记录移动的次数没有变，所以折半插入排序算法的时间复杂度仍然为O(n^2)，与直接插入排序算法相同。附加空间O(1)。

折半查找只是减少了比较次数，但是元素的移动次数不变，所以时间复杂度为O(n^2)是正确的！

```
void BiInsertSort(Recordlist L){
    int i,j,k;
    int low,high;
    
    for(i = 2;i <= L.lenghth;i++){
        if(L.r[i] < L.r[i-1]){
            L.r[0] = L.r[i];
            low = 1;
            high = i-1;
            while(low <= high){
                mid = (low + high)/2;
                if(L.r[0] < L.r[mid]){
                    high = mid -1;
                }else{
                    low = mid + 1;
                }
                
            }

            for(j = i-1;j >= low;j--){
                L.r[j+1] = L.r[j];
                L.r[low] = L.r[0];
            }
        }
    }


}
```